<?php

require_once dirname(__FILE__) . '/../stompPFPPendingProcessorSA.php';

/**
 * Test class for StompPFPPendingProcessorSA.
 * Generated by PHPUnit on 2011-06-22 at 15:20:36.
 */

class testPPPlogging extends StompPFPPendingProcessorSA{
    //protected $config_base;
    //protected $config_current;
    public $logdata;

    public function __construct( $config ) {
	require_once( $config['stomp_path'] );
        $this->config_base = $config;
	$this->load_config_options($this->config_base);
    }

    public function log( $message, $level=LOG_LEVEL_INFO ) {
	if ( $this->log_level >= $level ){
	    $out = date('c') . ": " . $level . " : " .  $message . "\n";
	    $this->logdata[] = $out;
	}
    }

    public function load_config_options($config){
	// Array of available configuration options
	$valid_options = array (
				'log_level',
				'pfp_url',
				'pfp_partner_id',
				'pfp_vendor_id',
				'pfp_user_id',
				'pfp_password',
				'activemq_stomp_uri',
				'activemq_pending_queue',
				'activemq_confirmed_queue',
				'batch_size',
				'stomp_path',);

	// loop through our options and set their values,
	// be sure to only take options that are valid
	foreach ( $valid_options as $option ) {
		// only process if this option was passed in by the user
		if ( !$config[ $option ] ) continue;

		// set class property with the config option
		$this->$option = $config[ $option ];

		$this->log( $option . " =  " . $this->$option, LOG_LEVEL_DEBUG );
	}

    }

    public function refreshConfig($config = array()){
        $this->config_current = array_merge($this->config_base, $config);
        $this->load_config_options( $this->config_current );
    }

    public function setGoodStompConnection(){
        $this->refreshConfig();
        return $this->set_stomp_connection();
    }

    public function setBadStompConnection() {
        $this->refreshConfig(array('activemq_stomp_uri' => 'CompleteNonsense'));
        return $this->set_stomp_connection();
    }

    public function getFetchNothing() {
	$this->setGoodStompConnection();
	$message = $this->fetch_message('/queue/test_empty');
	return $message;
    }

    public function getFetchFromPending() {
	$this->setGoodStompConnection();
	$message = $this->fetch_message($this->activemq_pending_queue);
	return $message;
    }

    public function addMessageToPending($message) {
	$this->setGoodStompConnection();
	return $this->queue_message( $this->activemq_pending_queue, $message);
    }

    public function getPayflowProStatus($transaction_id, $config = array()) {
	$this->refreshConfig($config);
	$status = $this->fetch_payflow_transaction_status($transaction_id);
	$decoded = $this->parse_payflow_transaction_status($status);
	return $decoded;
    }

}


class StompPFPPendingProcessorSATest extends PHPUnit_Framework_TestCase {

    /**
     * @var StompPFPPendingProcessorSA
     */
    protected $processor;

    protected $config_base;
    protected $config_current;
//
//    /**
//     * Sets up the fixture, for example, opens a network connection.
//     * This method is called before a test is executed.
//     */
    protected function setUp() {
//	$this->object = new StompPFPPendingProcessorSA;
	// set some configuration variables (for more info, check in PaypalIPNListener.php
	$this->config_base = array (
		'pfp_url' => 'https://payflowpro.paypal.com',
		'pfp_partner_id' => '',
		'pfp_vendor_id' => '',
		'pfp_user_id' => '',
		'pfp_password' => '',
		'activemq_stomp_uri' => 'tcp://localhost:61613',
		'activemq_pending_queue' => '/queue/test_donations',
		'activemq_confirmed_queue' => '/queue/test_confirmed',
		'batch_size' => 20,
		'log_level' => 2,
		'stomp_path' => '/var/www/civicrm/sites/all/modules/queue2civicrm/Stomp.php');

	// instantaite the processor with our config options
	$this->processor = new testPPPlogging($this->config_base);
    }
//
//    /**
//     * Tears down the fixture, for example, closes a network connection.
//     * This method is called after a test is executed.
//     */
//    protected function tearDown() {
//
//    }
    public function testLogHelpers() {
        $this->processor->log("Testing the log search function");
	if (!$this->checkLog("function", true)){
	    $this->markTestIncomplete("checkLog isn't working.");
	}
	if ($this->checkLog("function")){
	    $this->markTestIncomplete("checkLog isn't resetting properly.");
	}
    }


    public function testBootstrapAndStompConnection() {
	//test that a bad connection is properly logged
	$this->assertFalse($this->processor->setBadStompConnection(), "Bad Stomp Connection should return false");
	$this->assertTrue($this->checkLog("Stomp connection failed", true), "Bad Stomp Connection was not logged");

	//test that a good connection is properly logged
	$this->assertTrue($this->processor->setGoodStompConnection(), "Good Stomp Connection should return true");
	$this->assertTrue($this->checkLog("Successfully connected to Stomp listener", true), "Bad Stomp Connection was not logged");

    }

    public function testConstructLogs(){
	//destroy first. Then reconstruct. Don't assume.
	unset ($this->processor);
	$this->processor = new testPPPlogging($this->config_base);

	//test that the bootsrtapping mess got logged
	$checkLogItems = array();
	foreach ($this->config_base as $thing=>$otherthing){
	    if (trim($otherthing) != ''){
		$checkLogItems = $this->logCheckArrayAdd("$thing =  $otherthing", "Setting $thing was not logged.", $checkLogItems);
	    }
	}
	$this->assertLogEntries($checkLogItems, true);
    }

    public function testDestructLogs(){
	//unset (this->processor);
	$this->assertTrue(false, "Ugh. We destroy our logs right along with the object. Lame.");
    }

    public function testFetchTransactions() {
	//gee. We should really have a helper that puts one somewhere, in here, so we know what we're doing.
	$message = $this->processor->getFetchNothing();

	$checkLogItems = array();
	$checkLogItems = $this->logCheckArrayAdd("Attempting to connect to queue at", "Connection attempt not logged.", $checkLogItems);
	$checkLogItems = $this->logCheckArrayAdd("Attempting to pull queued item", "Queued item pull attempt not logged.", $checkLogItems);
	$checkLogItems = $this->logCheckArrayAdd("No message found", "No message found not logged.", $checkLogItems);

	$this->assertLogEntries($checkLogItems, true);

	$testmessage = json_encode(array(
	    'first' => 'This',
	    'second' => 'is',
	    'third' => 'my',
	    'fourth' => 'message!',
	));

	$this->processor->addMessageToPending($testmessage);
	//check the logs

	$message = $this->processor->getFetchFromPending();
	//check the logs
	$checkLogItems = $this->logCheckArrayRemove("No message found", $checkLogItems);
	$checkLogItems = $this->logCheckArrayAdd(print_r($testmessage, true), "Test Message Not Returned", $checkLogItems);

	$this->assertLogEntries($checkLogItems, true);

	
    }

    public function testPayflowPro(){
	//testing with bad creds and a bad transaction id
	$transaction_id = "nonsense";
	$creds = array(
	    'pfp_user_id' => 'mrMcNonsense',
	    'pfp_password' => 'nothing',
	    'pfp_vendor_id' => 'splunge',
	    'pfp_partner_id' => 'urr'
	);
	$decoded = $this->processor->getPayflowProStatus($transaction_id, $creds);

	$checkLogItems = array();
	$checkLogItems = $this->logCheckArrayAdd("Transaction ID: $transaction_id", "Transaction ID not logged.", $checkLogItems);
	$checkLogItems = $this->logCheckArrayAdd("PayflowPro query array:", "PayflowPro query array not logged.", $checkLogItems);
	$checkLogItems = $this->logCheckArrayAdd("PayflowPro query array (formatted):", "Formatted PayflowPro query array not logged.", $checkLogItems);
	$checkLogItems = $this->logCheckArrayAdd("to connect to PayflowPro...", "Attempt to connect PFP not logged.", $checkLogItems);
	$checkLogItems = $this->logCheckArrayAdd("Succesfully connected to PayflowPro", "Connection to PFP not logged.", $checkLogItems);
	$checkLogItems = $this->logCheckArrayAdd("PayflowPro reported status:", "PFP status not logged.", $checkLogItems);


	$checkLogItems = $this->logCheckArrayAdd("PayflowPro RESULT string:", "PFP result string not logged.", $checkLogItems);
	$checkLogItems = $this->logCheckArrayAdd("PayflowPro returned NO result code!", "PFP failure to return code not logged.", $checkLogItems);

	$this->assertLogEntries($checkLogItems, true);

	//PayflowPro result code:
	//PayflowPro returned NO result code!

	//TODO: Test with good creds and a bad tx#
	//TODO: Test with good creds and a good tx#
    //}
    }

    public function testExecuteLogs(){
	//TODO: Clear out whatever queue you want to use for this, populate it, and then manpiulate.
	$this->assertTrue(False, "This is not done. Clearly.");
	$this->processor->execute_K4();
    }


    public function checkLog($search, $clear = false) {
	//this should return something nice if it's got what you're looking for.
	$found = false;
	foreach ($this->processor->logdata as $whocares=>$line){
	    if (strpos($line, $search)){
		$found =  true;
	    }
	}
	if ($clear){
	    //clear the log
	    $this->processor->logdata = array();
	}
	return $found;
    }

    public function assertLogEntries($logCheckArray, $clear = false){
	foreach ($logCheckArray as $whocares=>$set){
	    $this->assertTrue($this->checkLog($set['search']), $set['display_error']);
	}
	if ($clear) {
	    //clear the log
	    $this->processor->logdata = array();

	}
    }

    public function logCheckArrayAdd($search, $display_error, $array){
	$array[] = array(
	    'search'=> $search,
	    'display_error' => $display_error
	);
	return $array;
    }

    public function logCheckArrayRemove($search, $array){
	foreach($array as $whocares=>$set){
	    if ($set['search'] == $search){
		unset($array[$whocares]);
	    }
	}
	return $array;
    }

}

?>
