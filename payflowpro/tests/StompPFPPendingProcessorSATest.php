<?php

require_once dirname(__FILE__) . '/../stompPFPPendingProcessorSA.php';

/**
 * Test class for StompPFPPendingProcessorSA.
 * Generated by PHPUnit on 2011-06-22 at 15:20:36.
 *
 * For this test file to run, you must boostrap phpUnit with the following file:
 * /fundraising-misc/testing_resources/phpUnit_bootstrap.php
 *
 * @author: Katie Horn <khorn@wikimedia.org>
 * @TODO: Um. Comments? Sheesh.
 */
$logdata = array();

class testPPPlogging extends StompPFPPendingProcessorSA {

	//protected $config_base;
	//protected $config_current;
	public $logdata;

	public function __construct($config) {
		require_once( $config['stomp_path'] );
		$this->config_base = $config;
		$this->load_config_options($this->config_base);
	}

	public function log($message, $level=LOG_LEVEL_INFO) {
		global $logdata;
		if ($this->log_level >= $level) {
			$out = date('c') . ": " . $level . " : " . $message . "\n";
			$logdata[] = $out;
		}
	}

	public function load_config_options($config) {
		// Array of available configuration options
		$valid_options = array(
			'log_level',
			'pfp_url',
			'pfp_partner_id',
			'pfp_vendor_id',
			'pfp_user_id',
			'pfp_password',
			'activemq_stomp_uri',
			'activemq_pending_queue',
			'activemq_confirmed_queue',
			'batch_size',
			'stomp_path',);

		// loop through our options and set their values,
		// be sure to only take options that are valid
		foreach ($valid_options as $option) {
			// only process if this option was passed in by the user
			if (!$config[$option])
				continue;

			// set class property with the config option
			$this->$option = $config[$option];

			$this->log($option . " =  " . $this->$option, LOG_LEVEL_DEBUG);
		}
	}

	public function setPFPTestMode($code = ""){
		$this->test_mode = true;
		if ($code != ""){
			$this->test_code = $code;
		}
		unset ($this->pfp_user_id);  //ARGHARGHARGH. That is all.
		$this->refreshConfig(array('pfp_user_id' => ''));
	}

	public function refreshConfig($config = array()) {
		$this->config_current = array_merge($this->config_base, $config);
		$this->load_config_options($this->config_current);
	}

	public function setGoodStompConnection() {
		$this->refreshConfig();
		return $this->set_stomp_connection();
	}

	public function setBadStompConnection() {
		$this->refreshConfig(array('activemq_stomp_uri' => 'CompleteNonsense'));
		return $this->set_stomp_connection();
	}

	public function getFetchNothing() {
		$this->setGoodStompConnection();
		$message = $this->fetch_message('/queue/test_empty');
		return $message;
	}

	public function getFetchFromPending() {
		$this->setGoodStompConnection();
		$message = $this->fetch_message($this->activemq_pending_queue);
		return $message;
	}

	public function ack_message($message) {
		return parent::ack_message($message);
	}

	public function addMessageToPending($message) {
		$this->setGoodStompConnection();
		return $this->queue_message($this->activemq_pending_queue, $message);
	}

	public function getPayflowProStatus($transaction_id) {
		$status = $this->fetch_payflow_transaction_status($transaction_id);
		$decoded = $this->parse_payflow_transaction_status($status);
		return $decoded;
	}

	public function fetch_message($queue) {
		return parent::fetch_message($queue);
	}

	public function queue_message($queue, $message) {
		return parent::queue_message($queue, $message);
	}

}

class StompPFPPendingProcessorSATest extends WM_TestCase {

	/**
	 * @var StompPFPPendingProcessorSA
	 */
	protected $processor;
	protected $config_base;
	protected $config_current;
	protected $base_message;

	protected $ignore = array(
		//add 'testname' => 'reason' in here, to avoid running (long/annoying/otherwise problematic) tests during development.
	);
	protected $singleTest = ""; //set this if you only want to run one test in the pile.

//
//    /**
//     * Sets up the fixture, for example, opens a network connection.
//     * This method is called before a test is executed.
//     */
	protected function setUp() {
//	$this->object = new StompPFPPendingProcessorSA;
		// set some configuration variables (for more info, check in PaypalIPNListener.php
		$this->config_base = array(
			'pfp_url' => '',
			'pfp_partner_id' => '',
			'pfp_vendor_id' => '',
			'pfp_user_id' => '',
			'pfp_password' => '',
			'activemq_stomp_uri' => '',
			'activemq_pending_queue' => '',
			'activemq_confirmed_queue' => '',
			'batch_size' => 20,
			'log_level' => 2,
			'stomp_path' => '');

		// instantaite the processor with our config options
		$this->base_message = array(
			'op' => 'Insert into queue',
			'submit1' => 'Insert into queue',
			'queue' => '/queue/test_donations',
			'contribution_tracking_id' => 'unittest1',
			'optout' => '0',
			'anonymous' => '0',
			'comment' => 'Generated with Unit Testing',
			'utm_source' => '112358134',
			'utm_medium' => '112358134',
			'utm_campaign' => 'unittesting',
			'language' => '2',
			'referrer' => 'http://example.com/2115175271',
			'email' => '2022397297@example.com',
			'first_name' => '287390372',
			'middle_name' => '1523362659',
			'last_name' => '44629465',
			'street_address' => '500653283',
			'supplemental_address_1' => '',
			'city' => 'San Francisco',
			'state_province' => 'CA',
			'country' => 'USA',
			'countryID' => 'US',
			'postal_code' => '60535',
			'gateway' => 'unit_test',
			'gateway_txn_id' => '1604643431',
			'response' => '900646333',
			'currency' => 'USD',
			'original_currency' => 'USD',
			'original_gross' => '23.50',
			'fee' => '0',
			'gross' => '23.50',
			'net' => '23.50',
			'date' => 'Wed, 22 Jun 2011 14:43:06 -0700',
			'submit2' => 'Insert into queue',
			'form_build_id' => 'form-1cb52594a56da97a1bda13cc2b1517eb',
			'form_token' => '0e7843c070bed0b6beb6bd652f719106',
			'form_id' => 'pending_processor_unit_test',
		);
		$this->config_base = array_merge($this->config_base, $this->getConfig());
		$this->processor = new testPPPlogging($this->config_base);
	}


    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown() {
		unset($this->processor);
    }

	protected function reInitProcessor(){
		unset($this->processor);
		$this->processor = new testPPPlogging($this->config_base);
	}

	protected function getConfig(){
		if (!file_exists("config.ini")){
			$this->fail("You need a config.ini file. Please make yours.");
		}
		$ini_config = parse_ini_file("config.ini");
		return $ini_config;
	}

	public function testLogHelpers() {
		$this->processor->log("Testing the log search function");
		if (!$this->checkLog("function", true)) {
			$this->markTestIncomplete("checkLog isn't working.");
		}
		if ($this->checkLog("function")) {
			$this->markTestIncomplete("checkLog isn't resetting properly.");
		}
	}

	public function testBootstrapAndStompConnection() {
		//test that a bad connection is properly logged
		$this->assertFalse($this->processor->setBadStompConnection(), "Bad Stomp Connection should return false");
		$this->assertTrue($this->checkLog("Stomp connection failed", true), "Bad Stomp Connection was not logged");

		//test that a good connection is properly logged
		$this->assertTrue($this->processor->setGoodStompConnection(), "Good Stomp Connection should return true");
		$this->assertTrue($this->checkLog("Successfully connected to Stomp listener", true), "Bad Stomp Connection was not logged");
	}

	public function testDestructConstructLogs() {
		//destroy first. Then reconstruct. Don't assume.
		unset($this->processor);
		$checkLogItems = array();
		$checkLogItems = $this->logCheckArrayAdd("Cleaning up stomp connection...", "Stomp Cleanup attempt not logged.", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd("Stomp connection cleaned up", "Stomp cleanup not logged.", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd("Exiting gracefully", "Graceful Exit not logged.", $checkLogItems);
		$this->assertLogEntries($checkLogItems, true);


		$this->processor = new testPPPlogging($this->config_base);
		//test that the bootsrtapping mess got logged
		$checkLogItems = array();
		foreach ($this->config_base as $thing => $otherthing) {
			if (trim($otherthing) != '') {
				$checkLogItems = $this->logCheckArrayAdd("$thing =  $otherthing", "Setting $thing was not logged.", $checkLogItems);
			}
		}
		$this->assertLogEntries($checkLogItems, true);
	}

	public function testFetchTransactions() {
		//gee. We should really have a helper that puts one somewhere, in here, so we know what we're doing.
		$message = $this->processor->getFetchNothing();

		$checkLogItems = array();
		$checkLogItems = $this->logCheckArrayAdd("Attempting to connect to queue at", "Connection attempt not logged.", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd("Attempting to pull queued item", "Queued item pull attempt not logged.", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd("No message found", "No message found not logged.", $checkLogItems);

		$this->assertLogEntries($checkLogItems, true);

		$testmessage = json_encode(array(
				'first' => 'This',
				'second' => 'is',
				'third' => 'my',
				'fourth' => 'message!',
			));

		$this->assertEmptyQueueWithAck($this->processor->activemq_pending_queue);

		$this->processor->addMessageToPending($testmessage);
		$this->assertTrue($this->checkLog("Attempting to queue message..."), "Message Queue Attempt was not logged");
		$this->assertTrue($this->checkLog("Result of queuing message:", true), "Message Queue Result was not logged");

		$this->processor->setGoodStompConnection();
		$message = $this->processor->getFetchFromPending();
		//check the logs
		$checkLogItems = $this->logCheckArrayRemove("No message found", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd(print_r($testmessage, true), "Test Message Not Returned", $checkLogItems);

		$this->assertLogEntries($checkLogItems, true);
	}

	public function testPayflowPro() {
		//testing with bad creds and a bad transaction id
		$transaction_id = "nonsense";
		$creds = array(
			'pfp_user_id' => 'mrMcNonsense',
			'pfp_password' => 'nothing',
			'pfp_vendor_id' => 'splunge',
			'pfp_partner_id' => 'urr'
		);
		$this->processor->refreshConfig($creds);
		$decoded = $this->processor->getPayflowProStatus($transaction_id, $creds);

		$checkLogItems = array();
		$checkLogItems = $this->logCheckArrayAdd("Transaction ID: $transaction_id", "Transaction ID not logged.", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd("PayflowPro query array:", "PayflowPro query array not logged.", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd("PayflowPro query array (formatted):", "Formatted PayflowPro query array not logged.", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd("to connect to PayflowPro...", "Attempt to connect PFP not logged.", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd("Succesfully connected to PayflowPro", "Connection to PFP not logged.", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd("PayflowPro reported status:", "PFP status not logged.", $checkLogItems);


		$checkLogItems = $this->logCheckArrayAdd("PayflowPro RESULT string:", "PFP result string not logged.", $checkLogItems);
		$checkLogItems = $this->logCheckArrayAdd("PayflowPro returned NO result code!", "PFP failure to return code not logged.", $checkLogItems);

		$this->assertLogEntries($checkLogItems, true);

		$this->processor->refreshConfig(); //it gets the good creds. :)
		$decoded = $this->processor->getPayflowProStatus($transaction_id, $creds);
		$this->assertLogEntries($checkLogItems, true);


		//PayflowPro result code:
		//PayflowPro returned NO result code!
		//TODO: Test with good creds and a bad tx#
		//TODO: Test with good creds and a good tx#
		//
	}
 
 

	public function testExecuteLogs_allpending() {
		global $logdata;
		//$this->fail("Just don't.");
		//Clear out whatever queue you want to use for this, populate it, and then manpiulate.
		$this->assertEmptyQueueWithAck($this->processor->activemq_pending_queue);
		//right now, I'm adding 10 messages because it's less than the batch size. We need to also make a test that
		//overruns the batch size, and test for... something. Hm. Maybe that it handles all the records
		//with two successive calls to execute().
		$added_ids = $this->assertAddTestMessagesToQueue(10, $this->processor->activemq_pending_queue, "pnd_", false);

		$this->processor->setPFPTestMode('126');
		$this->processor->execute();

		//check aaaaaall the logs.
		$this->assertItemHandlingLogs($added_ids);
		
		//TODO: Check the contents of the destination queue to make sure all our stuff is there.
	}

	

	public function testExecuteLogs_allFinal() {
		global $logdata;
		//Clear out whatever queue you want to use for this, populate it, and then manpiulate.
		$this->assertEmptyQueueWithAck($this->processor->activemq_pending_queue);
		//right now, I'm adding 10 messages because it's less than the batch size. We need to also make a test that
		//overruns the batch size, and test for... something. Hm. Maybe that it handles all the records
		//with two successive calls to execute().
		$added_ids = $this->assertAddTestMessagesToQueue(10, $this->processor->activemq_pending_queue, "fin_", false);

		$this->processor->setPFPTestMode('0');
		$this->processor->execute();

		//check aaaaaall the logs.
		$this->assertItemHandlingLogs($added_ids);

		//TODO: Check the contents of the destination queue to make sure all our stuff is there.
	}

	public function assertItemHandlingLogs($added_ids) {
		global $logdata;
		//we should maybe kill the lines out of the log when we're done with them.
		//the two arrays below go $transaction => $log_line_number
		$pendingLines = $this->assertPendingTransactionLogs($added_ids);
		$stompLines = $this->assertStompFrameLogs($added_ids);
		$resultLines = $this->assertResultHandlingLogs($added_ids);

		//PFP Logs will be between the Pending and Result lines! Ha!
        foreach ($added_ids as $key=>$item_id){
			$found = "";
			$connected = "";
			$status = "";
			for ($i = $pendingLines[$item_id]; $i<$resultLines[$item_id]; ++$i){
				if (!$found){
					if (strpos($logdata[$i], "No PFP Credentials") > 0){
						$found = "no creds";
					}
					if (strpos($logdata[$i], "PayflowPro query array:") > 0){
						$found = "query array";
					}
				} elseif($found == "query_array") {
					if (strpos($logdata[$i], "Succesfully connected to PayflowPro") > 0){
						$connected = "success";
					}
					if (strpos($logdata[$i], "PayflowPro reported status:") > 0){
						$status = "reported";
					}
				}
			}
			$this->assertFalse(empty($found), "No PayflowPro Connection Information Logged for $item_id");
			if ($found == "query array"){
				$this->assertFalse(empty($connected), "PayflowPro Successful Connection Not Logged for $item_id");
				$this->assertFalse(empty($reported), "No PayflowPro Status Reported for $item_id");
			}
			//echo "Found pfp connection logs for $item_id"; //just checking.
        }
	}

	public function assertPendingTransactionLogs($transactions) {
		//test that it's in the log in array format
		//  Line starts with "Pending transaction:"
		//  and contains "[contribution_tracking_id] => $item_id"
		global $logdata;
		$ret = array();
		$pendingLines = array();
		foreach ($logdata as $line_no => $line_data) {
			if (strpos($line_data, "Pending transaction:") > 0) {
				$pendingLines[$line_no] = $line_data;
			}
		}

		//at this point, the key and value of each $transactions is the same.
		foreach ($transactions as $id => $transaction) {
			foreach ($pendingLines as $line_no => $line_data) {
				if (strpos($line_data, "[contribution_tracking_id] => $id") > 0) {
					$transactions[$id] = $line_no;
				}
				break;
			}
			if (array_key_exists($transactions[$id], $pendingLines)) {
				unset($pendingLines[$transactions[$id]]);
			}
		}

		//at this point, they are only still the same if a line was not found.
		foreach ($transactions as $id => $logline) {
			$this->assertTrue($id != $logline, "Transaction $id has no Pending Transaction line in the log");
		}

		return $transactions;
	}

	public function assertStompFrameLogs($transactions) {
		//I realize I could abstract this out one further, but in the interests of getting this done in Ever...
		//...copied from assertPendingTransactionLogs.
		//test that it's in the log in complete message format, including json body
		//  Line starts with "Stomp_Frame Object"
		//  and contains "contribution_tracking_id":"$item_id"
		global $logdata;
		$ret = array();
		$stompLines = array();
		foreach ($logdata as $line_no => $line_data) {
			if (strpos($line_data, "Stomp_Frame Object") > 0) {
				$stompLines[$line_no] = $line_data;
			}
		}

		//at this point, the key and value of each $transactions is the same.
		foreach ($transactions as $id => $transaction) {
			foreach ($stompLines as $line_no => $line_data) {
				if (strpos($line_data, '"contribution_tracking_id":"' . $id . '"') > 0) {
					$transactions[$id] = $line_no;
				}
				break;
			}
			if (array_key_exists($transactions[$id], $stompLines)) {
				unset($stompLines[$transactions[$id]]);
			}
		}

		//at this point, they are only still the same if a line was not found.
		foreach ($transactions as $id => $logline) {
			$this->assertTrue($id != $logline, "Transaction $id has no Stomp Frame in the log");
		}

		return $transactions;
	}

	public function assertResultHandlingLogs($transactions) {
		//::sigh::

		//test for the next step line
		//Handling transaction " . $msgarray['gateway_txn_id'] . " with code $result_code

		global $logdata;
		$ret = array();
		$resultLines = array();
		foreach ($logdata as $line_no => $line_data) {
			if (strpos($line_data, "Handling transaction ") > 0) {
				$resultLines[$line_no] = $line_data;
			}
		}

		//at this point, the key and value of each $transactions is the same.
		foreach ($transactions as $id => $transaction) {
			foreach ($resultLines as $line_no => $line_data) {
				if (strpos($line_data, $id) > 0) {
					$transactions[$id] = $line_no;
				}
				break;
			}
			if (array_key_exists($transactions[$id], $resultLines)) {
				unset($resultLines[$transactions[$id]]);
			}
		}

		$forced_code = false;
		if (isset($this->processor->test_code)){
			$forced_code = $this->processor->test_code;
		}

		//at this point, they are only still the same if a line was not found.
		foreach ($transactions as $id => $logline) {
			$this->assertTrue($id != $logline, "Transaction $id has no Result Handling in the log");
			//BUT WAIT! There's more this time...

			if($forced_code){
				$this->assertContains("with code $forced_code", $logdata[$logline], "Forced Code($forced_code) not applied to item");
				switch($forced_code){
					case"0":
						$this->assertContains("Attempting to push message to confirmed queue:", $logdata[$logline+1],"Confirmed Message Attempt Not Logged");
						$this->assertContains("Succesfully pushed message to confirmed queue.", $logdata[$logline+4],"Confirmed Message Success Not Logged");
						break;
					case"126":
					case"26":
						$this->assertContains("Attempting to push message back to pending queue: ", $logdata[$logline+1],"Pending Message Pushed Back to Pending Attempt Not Logged");
						$this->assertContains("Succesfully pushed message back to pending queue", $logdata[$logline+4], "Message Pushed Back to Pending Not Logged.");
						break;
					default:
						$this->fail("Test Fail: You need to handle your forced code $forced_code");
				}
			} else { //no forced code: Could be mixed live data.
				//gosh, I wish I could switch on... not the entire next line.
				if(strpos($logdata[$logline+1], "Attempting to push message to confirmed queue:") > 0){
					$this->assertContains("with code 0", $logdata[$logline], "Message Confirmed WITHOUT Code 0");
					$this->assertContains("Succesfully pushed message to confirmed queue.", $logdata[$logline+4],"Confirmed Message Not Logged");
				} elseif(strpos($logdata[$logline+1], "Attempting to push message back to pending queue: ") > 0){
					$this->assertTrue((strpos($logdata[$logline], "with code 26") > 0 || strpos($logdata[$logline], "with code 126") > 0), "Message Pushed Back to Pending WITHOUT Code 26 or 126");
					$this->assertContains("Succesfully pushed message back to pending queue", $logdata[$logline+4], "Message Pushed Back to Pending Not Logged.");
				} else {
					$this->fail("Message is being ignored. This is almost certainly Not Good.");
				}
			}
		}

		return $transactions;
	}

	public function checkLog($search, $clear = false) {
		//this should return something nice if it's got what you're looking for.
		global $logdata;
		$found = false;
		foreach ($logdata as $whocares => $line) {
			if (strpos($line, $search) > 0) {
				$found = true;
			}
		}
		if ($clear) {
			//clear the log
			$logdata = array();
		}
		return $found;
	}

	public function assertLogEntries($logCheckArray, $clear = false) {
		global $logdata;
		foreach ($logCheckArray as $whocares => $set) {
			$this->assertTrue($this->checkLog($set['search']), $set['display_error']);
		}
		if ($clear) {
			//clear the log
			$logdata = array();
		}
	}

	public function logCheckArrayAdd($search, $display_error, $array) {
		$array[] = array(
			'search' => $search,
			'display_error' => $display_error
		);
		return $array;
	}

	public function logCheckArrayRemove($search, $array) {
		foreach ($array as $whocares => $set) {
			if ($set['search'] == $search) {
				unset($array[$whocares]);
			}
		}
		return $array;
	}

	public function assertAddTestMessagesToQueue($count, $queue, $tracker = "", $clearlog = false) {
		//insert $count nicely-formed messages into $queue
		$ret = array();

		$this->processor->setGoodStompConnection();
		for ($i = 0; $i < $count; ++$i) {
			$id = $tracker . 'unittest' . $i;
			$ret[$id] = $id;
			$tempmessage = $this->base_message;
			$tempmessage['contribution_tracking_id'] = $ret[$id];
			$tempmessage['gateway_txn_id'] = $ret[$id];
			$tempmessage['date'] = date("D, d M Y G:i:s O");
			$this->processor->queue_message($queue, json_encode($tempmessage));
			$this->assertTrue($this->checkLog("Attempting to queue message..."), "Message Queue Attempt $i was not logged");
			$this->assertTrue($this->checkLog("Result of queuing message:", $clearlog), "Message Queue Result $i was not logged");
		}
		return $ret;
	}

	public function assertEmptyQueueWithAck($queue) {
		//pull all the messages. Then ack them all.

		$this->processor->setGoodStompConnection();

		$message = $this->processor->fetch_message($queue);
		$i = 1;
		$messages = array();
		while (!empty($message)) {
			$messages[] = $message;
			$message = $this->processor->fetch_message($queue);
			++$i;
		}

		foreach ($messages as $key => $message) {
			$this->processor->ack_message($message);
			//and check the logs

			$this->assertTrue($this->checkLog("Attempting to ack message..."), "Message Ack Attempt $key was not logged");
			$this->assertTrue($this->checkLog("Result of message ack:", true), "Message Ack Result $key was not logged");
		}

		//so now the queue should be completely empty. Well, as long as it's just ours...
		//let's try this: reset the connection and try to get one.
		$this->processor->setGoodStompConnection();
		$message = $this->processor->fetch_message($queue);
		$this->assertTrue(empty($message), "There was a message in the queue that was supposed to be empty." . print_r($message, true));
	}

}
?>
